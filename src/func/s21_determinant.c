#include "../s21_matrix.h"

// Определитель матрицы (determinant)
int s21_determinant(matrix_t *A, double *result) {
  int status = OK; // Инициализация статуса выполнения

  // Проверка корректности входных данных: матрица и указатель на результат должны быть корректными
  if (!(A && result && A->matrix)) 
    status = INCORRECT_MATRIX; // Ошибка, если матрица или указатели некорректны

  // Проверка, что матрица квадратная (количество строк равно количеству столбцов)
  else if (A->columns != A->rows) 
    status = CALCULATION_ERROR; // Ошибка вычисления, если матрица не квадратная
  
  // Если все проверки пройдены, вызываем функцию для вычисления определителя
  else {
    *result = s21_my_determinant(A); // Вычисляем определитель и сохраняем результат
  }

  return status; // Возвращаем статус выполнения
}


double s21_my_determinant(matrix_t *A) {
  double result = 0; // Переменная для хранения результата

  // Если матрица 1x1, определитель равен единственному элементу
  if (A->rows == 1) {
    result = A->matrix[0][0];
  } else {
    matrix_t now = {0}; // Создаем временную матрицу для хранения минора

    // Создаем матрицу для минора, которая на одну строку и один столбец меньше исходной
    s21_create_matrix(A->columns - 1, A->rows - 1, &now);

    // Проходим по первой строке и для каждого элемента вычисляем минор и его определитель
    for (int i = 0, sign = 1; i < A->rows; i++, sign *= (-1)) {
      s21_my_minor(A, 0, i, &now); // Вычисляем минор для элемента [0][i]

      // Вычисляем сумму с учетом знака и умножаем на определитель минора
      result += sign * A->matrix[0][i] * s21_my_determinant(&now);
    }

    s21_remove_matrix(&now); // Освобождаем память, выделенную для минора
  }

  return result; // Возвращаем результат
}


// Минор элемента
void s21_my_minor(matrix_t *A, int skipX, int skipY, matrix_t *result) {
  // Проходим по всем строкам и столбцам результата, пропуская указанные строки и столбцы
  for (int i = 0, x = 0; i < result->rows; i++, x++) {
    if (i == skipX) {
      x++; // Пропускаем строку skipX
    }
    for (int j = 0, y = 0; j < result->columns; j++, y++) {
      if (j == skipY) {
        y++; // Пропускаем столбец skipY
      }
      // Копируем элемент из матрицы A в матрицу-минор
      result->matrix[i][j] = A->matrix[x][y];
    }
  }
}
